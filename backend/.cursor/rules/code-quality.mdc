# Code Quality Guidelines

## Code Formatting
- **Ruff**: Use Ruff for fast Python linting and formatting
- **Line Length**: Maximum 120 characters per line
- **Auto-fix**: Ruff automatically fixes many issues
- **Import Sorting**: Ruff handles import organization

## Linting Rules
- **Pyflakes (F)**: Catch logical errors and unused imports
- **Pycodestyle (E, W)**: Follow PEP 8 style guidelines
- **Complexity (C)**: Maintain reasonable code complexity
- **Pyupgrade (UP)**: Use modern Python syntax
- **Isort (I)**: Organize imports consistently

## Type Hints
- **Comprehensive**: Use type hints for all function parameters and return values
- **Pydantic**: Use Pydantic models for data validation
- **Optional**: Mark optional parameters with `Optional[Type]`
- **Union**: Use `Union[Type1, Type2]` for multiple possible types

## Code Style
- **Docstrings**: Add docstrings to all public functions and classes
- **Naming**: Use descriptive names following Python conventions
- **Constants**: Use UPPER_CASE for constants
- **Functions**: Keep functions focused and single-purpose

## Running Quality Checks
- **Format**: `make format` - Auto-format code with Ruff
- **Lint**: `make lint` - Run all linting checks
- **Type Check**: `mypy src/` - Static type checking
- **Pre-commit**: Consider setting up pre-commit hooks

## Example Code Style
```python
from typing import Optional, List
from pydantic import BaseModel

class ItemCreate(BaseModel):
    """Schema for creating a new item."""
    name: str
    description: Optional[str] = None
    tags: List[str] = []

async def create_item(item_data: ItemCreate) -> dict[str, object]:
    """Create a new item in the database.
    
    Args:
        item_data: The item data to create
        
    Returns:
        The created item data
    """
    # Implementation here
    pass
```
globs: src/**/*.py,tests/**/*.py
---
